#### 一、概述

​	行为树节点大致可以分为三大类：复合节点、辅助结点、任务节点。其中复合节点一般是作为父节点，他往往代表着一种选择下一个执行的子节点/子树的规则。辅助节点包括装饰器节点和服务节点，装饰器节点用于判断当前分支是否可以执行，以及当条件发生变化时可以中断当前正在执行的分支。服务节点比较简单，类似一个监视器，当所属分支正在运行时按照一定的时间间隔运行指定逻辑，服务节点无法单独作为一个行为树节点，而是必须依托在复合节点或任务节点上。任务节点顾名思义用于执行任务，包括运行一颗新行为树，任务节点只会作为行为树的叶节点，它不会有自己的子树。

#### 二、复合结点

##### 2.1 UE自带的复合节点

​	UE自带的复合节点包括Selctor和Sequence，其中Selctor的执行策略是有一个分支执行成功就返回成功，否则返回失败;Sequence的执行策略是所有分支执行成功才会返回成功，否则返回失败。也就是说Sector会执行直到有一个分支成功，Sequence会执行直到有一个分支失败。

##### 2.2 关键结构

​	复合节点中最关键的数据应该是TArray\<FBTCompositeChild\> Children;这是一个包含所有子节点信息的数组，包括子节点上附加的**装饰器**节点，其实也都存在复合节点的Children数组当中，这是一个比较反直觉的设计，这意味着如果单单拿到子节点的指针，是无法获取它身上附着着的装饰器节点。FBTCompositeChild结构中除了两个存辅助节点的数组之外还有两个指针，分别代表辅助节点和任务节点，其中只可能有一个指针不为空，因为还不确定指向的子节点是个任务节点还是一颗子树。至于服务节点，它存在复合节点自己身上

![image-20241118021810159](D:\WPS\MyNote-main\noteImage\image-20241118021810159.png)

​	第二重要的就是这个虚函数GetNextChildHandler，要定义自己的复合节点(例如随机选一个分支执行)理论上只需要重写这个函数![image-20241118022536524](D:\WPS\MyNote-main\noteImage\image-20241118022536524.png)

![image-20241118022709120](D:\WPS\MyNote-main\noteImage\image-20241118022709120.png)

#### 三、辅助节点

​	辅助节点中Service节点比较简单，基本就是提供一个Tick功能的节点，装饰器节点比较复杂。装饰器节点最核心的函数是CalculateRawConditionValue，用于判断当前分支是否满足执行条件，自定义装饰器基本上就是在重写这个函数。

![image-20241118031723728](D:\WPS\MyNote-main\noteImage\image-20241118031723728.png)

​	除此以外装饰器节点最重要的功能就是打断，EBTFlowAbortMode代表中断类型，其中LowPriority代表中断优先级比自己低的分支(例如同一层级下右侧的分支)，Self只打断自己所属分支，而Both兼容了上述二者，打断包括自己在内的所有比自己优先级低的节点

![image-20241118031946497](D:\WPS\MyNote-main\noteImage\image-20241118031946497.png)

​	TODO ConditionalFlowAbort

#### 四、任务节点

​	任务节点比较简单，唯一值得关注的只有ExecuteTask函数，自定义任务节点基本上等同于重写这个函数![image-20241118032354044](D:\WPS\MyNote-main\noteImage\image-20241118032354044.png)

#### 五、 节点内存

​	UE的行为树中，所有的节点都默认是单例模式，也就是说对于多个使用同一棵行为树的AI而言，它们跑的是同一棵树，因此节点里的成员变量也不可随意更改。例如ExecuteTask的官方注释中就有说明如果节点没有**实例化**，则应该将这个函数视为const函数。那么问题来了，如果我有需求需要在节点上存一些东西，一些对于不同使用者来说值不一样的变量该怎么操作呢，答案是重写节点的GetInstanceMemorySize函数，这个函数在节点被初始化的时候会被调用，它并不是返回节点本身的大小，而是告诉BehaviorTreeManager你需要多少私人空间，在节点的父类UBTNode中这个函数直接返回0。需要读写这些私人空间的时候调用CastInstanceNodeMemory，将地址转换为对应结构体即可![image-20241118033829504](D:\WPS\MyNote-main\noteImage\image-20241118033829504.png)

​	简单来说就是：

	1. 在对应的节点里声明一个结构体，将自己需要的数据定义在里面，然后重写节点的GetInstanceMemorySize，返回Sizeof(MyStruct)，然后Manager会为这个节点申请一块内存。
	2. 需要使用的时候调用CastInstanceNodeMemory，类型转换一下即可。

​    当然也有更简单的方式：不让节点以单例模式运行，为每棵树创建一个单独的节点实例，只需要在构造函数里将bCreateNodeInstance 设置为true即可，不过一般不这么做，因为显然单例模式在内存开销和寻址上更有优势。