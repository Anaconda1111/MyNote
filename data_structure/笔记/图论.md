## 一、图的表示方法

​	表示一张图G=(V，E)的方法有两种，分别是邻接链表与邻接矩阵。邻接矩阵好理解，第i行第j列的值即是点i到j的距离（假如这两点是直接连通的），但是假如图中存在大量的节点但是彼此之间连接少，将会导致邻接矩阵中大部分位置为0，造成空间上的浪费，这种情况应该用邻接链表储存图，即图的节点组成一个链表，每一个节点V都延展出一条路径链表，用于储存该点与其他有连接的点的距离和点的名称。

<img src="D:\Daer\data_structure\笔记\图片\图1.jpg" alt="无向图" style="zoom:150%;" />

<img src="D:\Daer\data_structure\笔记\图片\图2jpg.jpg" alt="有向图" style="zoom:150%;" />

## 二、最短路径算法

## 	2.1 无权图最短路径

​		1.基本思路：无权图中各个路径的长度都为1。首先找到与起始点有连接的点，将这些点与起始点的距离标记为1，然后将这些点都放入一个FIFO结构（普通队列即可实现）中，再依次取出并遍历其连接点，将其与起始点的距离标记为2，然后再将这些点放入队列中，以此类推，直到遍历完整张图。这种搜索一个图的方法被称为广度优先搜索，遍历完整张图后可得到起始点与所有点之间的最短距离。

​		2.实现：这种算法的实现需要用一个二维的表格，大小为VertexNum*3，三列分别为know，distance，path，know域本是用于让已经参与过运算的节点不再重复使用，但是通过将distance域初始化为infinite也可达到这个效果，path域用于帮助打印路径，如果只是求最短距离，也可忽略。初始化完表格后，将起始点放入队列，当队列不为空时循环地将队列中节点取出（记为V），更新表格中与该节点相连的点的distance（即为W（V）+1，只有该点的distance仍为infinite时才执行这一步操作），然后将这些节点入队。