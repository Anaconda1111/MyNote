### 条款19 设计class犹如设计type

​	设计class之前必须考虑的设计规范：

1.  新type的对象应该如何被创建和销毁：这会影响到构造函数、析构函数和内存分配、释放函数。
2.  对象的初始化和对象的赋值应该有什么样的差别：这将决定对象的构造函数和assignment操作符的行为
3.  什么是新type的合法值：对于某些成员变量，通常只有某些数值是有效的。
4.  新对象如果是passed by value时将意味着什么：copy构造函数将决定这个type的passed by value如何实现
5.  新type需要配合某个继承图系吗：如果继承自某些已有的类，就要受到那些class的设计束缚，特别是虚函数方面，如果你允许其它类继承你的class，那会影响你所声明的函数是否为virtual，尤其是虚函数。
6.  新type需要什么样的转换：是否允许隐式类型转换(或者说是否需要)
7.  什么样的操作符和函数对此新type而言是合理的
8.  什么样的标准函数应该驳回：那正是你必须声明为private者
9.  谁该取用新type的成员：决定哪个成员为public，哪个为protected，哪个为private

### 条款23 宁以non-member、non-friend替换member函数

​	面对对象守则要求数据应该尽可能被封装，而一个反直觉的结论就是：member function比non member更加破坏封装性，因为越多函数可以访问数据，数据的封装性就越低，当一个函数的功能可以由member function和non member function完成时，应该选择用non member function。
​	一个利用non member function的例子：

```c++
//webbrowser.h头文件：
//此头文件内提供类WebBrowserStuff的核心功能
namespace WebBrowserStuff{
    class WebBrowserStuff{...};
}
```

```c++
//webbrowsercookies.h头文件
namespace WebBrowserStuff{
    ...//与书签相关的便利函数
}
```

```c++
//webbrowsercookies.h
namespace WebBrowserStuff{
    ...;//与cookie相关的便利函数
}
```

​	这种组织加构有许多优点，将一些便利函数设计为non member function，并用namespace分割在不同头文件内，这样有解耦合的作用，当你想对某一方面的便利函数新增内容时只需要修改对应的文件就行，不用修改类的内容。

### 条款24：若所有参数皆需要类型转换，请为此采用non member函数

​	假设有一个类代表有理数，它的两个数据成员分别代表分子(numerator)和分母(denominator)：

```c++
class Rational{
    public:
    	Rational(int numerator=0,int denominator=1);//构造函数允许隐式类型转换，因为将一个int
    	int numerator() const;					  //转换为有理数class很自然
    	int denominator() const;
    private:
    	...;
}
//假如现在要有一个operator*函数，那它应该是成员函数还是非成员函数呢？
//答案应该是非成员函数：
Rational oneHalf(1,2);
Rational result;
result=oneHalf*2;//没问题，因为2可以隐式转换为Rational对象
result=2*oneHalf;//只有non member operator* function才可以这样写
```

