### 条款32 确定Public继承塑膜出is-a关系

​	public继承意味着is-a，即**适用于base class身上的每一件事情也一定适用于derived class身上**。因为每一个derived class也都是一个base class对象，反之则不然。设计程序的时候容易对is-a关系有误判，例如矩形和正方形的关系，直觉上肯定觉得正方形is-a矩形，但能对矩形做的事情并不都能对正方形做，例如单独改变其宽度而不该被其高度，所以如果用public继承处理矩形和正方形的关系可能会引发一些问题。
​	另外一个例子是鸟类与企鹅，企鹅是一种鸟类，但企鹅不会飞，所以在base class鸟类中，不能够定义fly函数。一般的鸟类(或者说绝大多数鸟类)都可以飞，但只要有一小部分不会，就不能在其中定义fly函数，这体现了基类中的成员函数必须具有完全的一般性。当然如果要设计的程序完全不考虑飞行这件事，就不必特地在代码中区分这一点。世界上并不存一个适用于所有软件的完美设计，所谓最佳设计，取决于系统希望做什么事，包括现在与未来。

### 条款33 避免遮掩继承而来的名称

​	派生类与基类的成员名称实际运作规则是：**派生类作用于被嵌套在基类作用域内**。这里讨论的名称不单是成员函数(包括纯虚函数、虚函数和非虚函数)，也包括其它类型，例如枚举、typedefs等。

```c++
class Base{
    private:
    	int x;
   	public:
    	virtual void mf1()=0;
    	virtual void mf2();
    	void mf3();
   	...
};
class Derived:public Base{
    public:
    	virtual void mf1();
    	void mf4();
}

//假设派生类的mf4函数的实现如下：
void Derived::mf4(){
    ...
    mf2();
    ...
}
//当编译器看到mf2这个名称，会先在local作用域查找，也就是mf4的定义式内，没找到再去派生类的作用域中
//查找，最终还是没找到的话，再去基类的作用域中查找，最终找到那个函数了。
//如果在base作用域中仍然没找到，就去Base class所在的namespace作用域中查找，最终往global作用域找去
```

而如果在派生类当中对基类的某个函数进行重载，那么有可能会屏蔽掉基类的版本，也就是说base class内的所有相应的函数都被派生类的所取代，相当于这些函数不再被继承：

```c++
class Base{
    private:
    	int x;
   	public:
    	virtual void mf1()=0;
    	virtual void mf1(int);//一个带参数的重载版本
    	virtual void mf2();
    	void mf3();
    	void mf3(double);//同，带参重载版本
   	...
};
class Derived:public Base{
    public:
    	virtual void mf1();
    	void mf3();
    	void mf4();
}
//可以看到，对于虚函数的mf1和非虚函数的mf3，派生类都只定义了无参版本，这种行为会将基类的带参版本给屏蔽掉：
Dervied d;
int x;
d.mf1(x);//错误
d.mf1();//正确
d.mf3(x);//错误
d.mf3();//正确
//上述规则适用于所有类型的成员函数，包括虚的和非虚的，那么假设只想重写基类的重载了的虚函数中的一个该怎么办呢
//做法如下：
class Derived:public Base{
    public:
    	using Base::mf1;
    	using Base::mf3;
    	virtual void mf1();
    	void mf3();
    	void mf4();
}
//将代码进行以上修改，则基类的函数仍然被全部被继承，只不过一部分被派生类重写为派生类版本了
d.mf1(x);//正确 调用Base::mf1(int)
d.mf1();//正确 调用Derived::mf1();
d.mf3(x);//正确 调用Base::mf1(int);
d.mf3();//正确  调用Derived::mf3();
```

​	上述代码意味着，如果继承base class并加上重载函数，而你又希望重新定义或覆写其中一部分，就必须为那些原本会被遮掩的名称引入一个using声明式，否则那些希望被继承的名称将被遮掩。Tips:假设基类虚函数没有重载，而派生类的同名的虚函数的参数列表不一样，那么派生类会隐藏基类的虚函数。
​	如果继承关系是public继承(也就是is-a关系), 那么毫无疑问派生类必须全部继承基类的所有函数。但如果不是公有继承,则有可能发生只需要继承一部分base class的函数, 此时就不能使用using声明式了,而应该使用转交函数:

```c++
class Derived:private Base{
    public:
    	virtual void mf1(){//转交函数，这样子假设基类有多个mf1，派生类将屏蔽其它版本而只继承无参数的版本
            Base::mf1();
        }
}
```

### 条款34 区分接口继承和实现继承

1.  声明一个pure virtual函数的目的是为了让derived classes只继承函数接口。纯虚函数有两个最突出的特性：必须被重新声明、通常在抽象基类中没有定义。
2.  声明一个inpure virtual函数的目的是为了让派生类继承该函数的接口和缺省实现。当派生类没用重写基类虚函数时，默认使用基类版本的函数，但这有可能引发问题：当某个派生类在逻辑上不能使用缺省实现且写派生类的时候忘记重写该虚函数的时候，当相应的派生类对象调用该函数，会出现逻辑上的bug。如果有这种情况，还是将对应的虚函数声明为纯虚函数，并在抽象基类中定义该纯虚函数以提供缺省行为，纯虚函数可以迫使其派生类一定要重写它，否则编译器报错！  另一种做法是，同样的定义纯虚函数，但将缺省行为放在另外一个函数内，并将这个函数放在保护域中。
3.  声明非虚函数是为了令派生类继承函数的接口及一份强制性实现。这意味着对于这个函数，其不变性应该凌驾于特异性之上，它绝不应该在派生类中被重新定义。

### 条款36 绝不重新定义继承而来的non-virtual函数

​	派生类如果重新定义继承而来的非虚函数，将会屏蔽基类版本。这将导致不同静态类型的指针指向同一个对象时，对这个非虚函数的调用结果不一致。

### 条款37 绝不重新定义继承而来的缺省参数值

​	缺省参数值是由变量的静态类型决定的，而具体调用哪个函数(这里默认是虚函数，才可以被派生类覆写)取决于变量的动态类型。如果重定义缺省参数值，指向派生类的指针调用该虚函数时，使用的缺省参数值却是基类版本的。
​	那么如果每个派生类都将缺省参数值设置得与基类相同，问题是否解决了呢。答案是解决了但不完美，因为这意味着有相同的代码，相同的代码意味着将产生依存性，也就是说如果基类的参数发生改变，派生类的参数得一个一个改。可以使用NVI设计模式：即令base class内的一个public non virtual函数调用private virtual函数，后者可被派生类重新定义

```c++
class Shape{
    public:
    enum ShapeColor{Red,Green,Blue};
    void draw(ShapeColor=Red) const{
        doDraw(ShapeColor);//调用真正进行工作的private virtual function
    }
    private:
    virtual void doDraw(ShapeColor) const =0;//pure virtual，派生类一定要重新定义
}
```

### 条款39 明智而审慎地使用private继承

1.  private继承意味着is-implemented-in-terms-of(根据某物实现出)。它通常比复合的级别低。但是当derived class需要访问protected base class的成员，或需要重新定义继承而来的虚函数时，使用private继承是合理的。
2.  和复合不同，private继承可以造成empty base最优化，即如果基类为空时，单独的一个基类对象所占内存往往不为0，如果在其它类中复合改基类对象，则所占的内存要加上这个空基类对象的内存。但如果是使用private继承，派生类对象中基类部分将不占任何内存，真正变成空对象。

### 条款40 明智而审慎地使用多重继承

1. 多重继承比单一继承复杂，可能导致名称歧义性以及对virtual继承的需要。

 	2. virtual继承会增加对象的大小、运行速度、初始化复杂度等成本，如果virtual base class不带任何数据，那将是最具实用价值的情况。
 	3. 多重继承也有其正当用途，例如设计public继承某个class和private继承某个用于协助实现的class。