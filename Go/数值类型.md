## 一、常量与变量

### 1.1 常量

​	Go中常量用const声明，可以为其指定数值类型，例如const limit uint16=1421，如果没有指定数值类型，则其类型兼容任何数字。

### 1.2 枚举

​	枚ye举是一种便捷的声明常量的方式，可以不用一个个地用const修饰，例如：

```go
const (
	red=1
    blue=2
    yellow=3
)
```

​	如此便可快捷地声明一组常量。这种方式有一定的规则：

1. 如果第一个常量没有显式设置，则其为0，第二个以及随后的值与**它们的前一个值**相同。
2. 如果第一个常量设为iota，则后面每一个变量的值都为iota，但iota每次都会自增1，也就是说后面的每一个常量都将被赋予前一个常量+1的值。且每次遇到const，iota的值都会重置为0

### 1.3 变量

​	Go中的变量可以使用var关键字声明，例如 var x=10，也可以使用快捷变量声明语法：x:=10。通常的做法是不去显式地声明其类型，除非要使用一个Go无法推断的特殊类型。

### 1.4 布尔值

​	包括Ture和False，比较操作符的成员与C一样。Go会严格筛选用于比较操作符进行比较的值，这些值必须是同类型的，如果是接口就必须实现了相同的接口类型，如果是常量就必须那么它的类型就必须与另一个类型兼容。这意味**着一个无类型的数值常量可以跟任意数值类型的值比较，但不同类型且非常量的数值不能直接比较，除非其中一个显式转换为另一个的类型**

## 二、数值类型

### 2.1 整型

​	Go中提供了11种整型，分别为 byte(8位)、int、int8、int16、int32、int64、rune(32位)、uint、uint8、uint16、uint32、uint64、uintptr。其中int、uint、uintptr在不同平台下位数不一样(可能是32位也可能是64位)
​	这些整型使用时并不像C或C++那样，而是类似一种函数调用，例如 a:=int(10) , b:=int32(50)

### 2.2 浮点类型

​	Go中提供了两种浮点类型和两种复数类型。分别是：float32、float64、complex64，complex128。对于浮点数之间的比较，直接用==或！=可能会导致问题，原因自然就是计算机储存浮点数时的精度问题，最好使用函数EqualFloat()

## 三、字符串

​	Go中的字符串可以用UTF-8表示Unicode编码。每一个Unicode字符都有一个唯一的叫做码点的标识数字，Go中单一的码点用rune的形式存储(等价于int32)，也就是说，Go中的字符串，但一个字符可能由多个字节构成。

### 3.1 字面量、操作符和转义

1. 字面量：字符串字面量用""或‘’创建。前者创建的是**可解析**的字符串字面量，意思就是其中可以包含转义字符，但不能引用多行。而后者创建的是原生字面量字符串，可以包括多行但不支持任何转义字符。

 	2. 字符转义：类似C中\n 、\r这样的形式。
 	3. 操作符：
      1. +：级联操作符，例如 a:="abc"+"def"  //  a等于"abcdef"
      2. +=：追加操作符，Go中字符串虽然不可变，但支持追加操作符，将一个字符串追加到原字符串的末尾
      3. [n]：字符串s中索引位置位n(uint8类型)的原始字节
      4. [n:m]：从位置n~m-1处的字符串
      5. [n:]：从位置n到字符串末尾的字符串
      6. [:m]：从位置0到位置m-1处的字符串，相当于[0,m)
      7. len([]rune(s)) : 字符串s中**字符的个数**，由于Go中字符串的一个字符可能有多个字节组成，而每个字符肯定都可以由一个rune类型的数据来表示，因此将字符串转换为rune类型的切片，再求出切片长度即为字符串长度
      8. []rune(s)：将字符串s转换为一系列码点(即int32类型的切片，Unicode字符的码点正是这个类型)
      9. string(chars)：将一个[]rune或[]int32转换为字符串

### 3.2 比较字符串

​	Go语言支持对字符串进行常规的比较操作，例如<、<=、==、!=   这些比较操作符将一个字节一个字节地比较字符串

## 四、集合类型

### 4.1 指针

​	Go中也有和C++/C一样的指针，其用法也一样。对于普通数值类型，函数参数是按值传参，只能改变其副本，要想改变数据本身必须传入引用或指针。

### 4.2 数组

​	Go中数组与C/C++中数组类似，其长度均为声明时确定且不可更改，声明方式如下：

```go
//[length]Type
//[N]Type{V1,V2,V3,...,VN}
//[...]Type{V1,V2,...VN} 这种情况下Go自动计算出数组长度
var buffer [20]byte
var grid1 [3][3]int
```

​	可用内置的len函数得到数组的长度，用 [ ]的方式对数组元素进行索引。数组可以用与字符串类似的切片语法进行切片，但其结果为一个切片而非数组。

### 4.3 切片

​		Go中很少用数组，更多时候如果需要一组数据则选择切片实现最好。切片属于引用类型，函数传参时开销很小，而如果是数组需要按值传递，在比较大的数据集合的情况下开销比较大。创建切片的方法如下：

```go
make([]type,length,capacity) //make是Go内置的函数，可用于创建切片
make([]type,length)
[]type{}
[]type(v1,v2,...,vn)
```

​	切片的底层实现实际上是数组，但不同之处在于其长度可变。对切片进行分割操作，例如s[n:m]，得到的结果也是一个切片，但主要，**它与原切片引用的是同一个数组**，对后者的修改会反映到前者上。

#### 4.3.1 索引与分割切片

​	切片的索引方式与数组相同，均是用[index]的方式索引。而分割上，也是用[n:m]的方式分割出一个子切片，且切片是引用类型，子切片上的修改，原切片也会受影响。有一种情况除外：对子切片进行插入元素操作，切片的容量与其长度相同，插入新元素时会创建一个新的、容量+1的切片并将原有元素复制过去(包括新元素)，此时的子切片与原切片就是两个不同的切片了，对子切片的任何操作与原切片无关。

#### 4.3.2 遍历切片

​	一般使用for range遍历切片，如果涉及对切片元素的修改，则必须用下标索引进行修改，例如

```go
f:=[]int{1,2,3,4,5,6,7,8}
for _,n := in range f{
    fmt.printLn(n)   //此时的n是副本！对n的修改无法反映到原数组
}

for i := range f{
    f[i]+=1    //通过下标索引的方式访问切片元素，此时就可以修改
}

```

#### 4.3.3 修改切片

​	对切片元素的新增和删除都可以使用Go内置的append函数实现。append用于在切片**末尾新增元素**，它接收两个参数，第一个是需要新增元素的切片，第二个是与原切片**类型相同**的值或者切片：

```go
a:=[]int{1,2,3}
b:=[]int{5,6,7}
a=append(a,4)  // a--> {1,2,3,4}  新增单个元素
a=append(a,b...)  // a-->{1,2,3,4,5,6,7} 这是append切片的语法，三个点表示把切片内的元素都新增进去
```

而通过对append函数的灵活运用，可以实现任意位置的插入元素：

```go
func InsertInt(nums []int,index, val int) []int{
	result:=make([]int,len(nums)+1)
	at:=copy(result,nums[:index]) //copy函数，将第二个切片的元素复制到第一个切片，并返回个数
	result[at]=val
	at+=1
	copy(result[at:],nums[index:])
	return  result
}
```

而元素的删除，如果是前缀切片的删除或后缀切片的删除，通过切片切割语法即可实现：

```go
s=s[:2]  //删除从下标2开始往后的所有元素
s=s[2:] //删除s[0]   s[1]
```

而实现任意位置的删除则同样需要append函数：

```go
func DeleteInt(nums []int,index int) []int {
	nums=append(nums[:index],nums[index+1:]...)  //先取截止到被删除元素的子切片，然后将后面一段插入
	return nums
}
```

####	4.2.4 切片排序和搜索

切片排序可以用sort包内置的函数，而该包中的search函数用二分查找来在一个有序切片中查找目标元素。

### 4.4 映射

​	映射是Go语言的内置类型，其实就是哈希表。其成员为一个个的键值对，其键指必须支持==和！=操作符的类型，切片、不能用于比较的数组和结构体或一些不能比较的自定义类型，均不可作为键值。
​	映射表中的键的类型必须是相同的，值也一样

#### 4.4.1 创建映射表

```go
make(map[keytype]valuetype,capacity)
make(map[keytype]valuetype)
map[keytype]valuetype
map[keutype]valuetype{key1:value1,key2:value2...}
```

​	要访问映射表中的内容，用[]操作符，例如city["beijing"]，相当于访问映射表city中，键为“beijing”的值，这样的操作会返回两个值，一个是value，一个是bool值，**假如该键值对不存在，value会返回对应类型的0值，而第二个返回值为false，存在则为true**。

#### 4.4.2 遍历映射表

```go
for key,value := range hashtable{
    ......
}
//for range循环遍历映射表时，对于其中每一项都返回其键和值
```

#### 4.4.3 新增与删除

​	新增条目时，直接用 table[newkey]=newvalue的形式即可，如果键已经存在则更新它的值。而至于删除操作，由函数delete完成：delete(tablename , key)