

## 虚拟内存

### 1. 概念

​	在同一台计算机上运行的多个进程，为了避免彼此之间在物理内存上互相干扰(如进程A写入了进程B所使用的物理内存)，程序中所使用的内存都是虚拟内存。
​	当程序要写入虚拟内存的时候，操作系统会将对应的虚拟内存地址转换为物理内存地址，这样不同的进程同时运行的时候，使用的就是不同的物理地址，就不会发生冲突了。将虚拟内存转换为物理内存是由CPU中的MMU(内存控制单元)完成的，CPU首先拿到虚拟内存，再由MMU转换为物理内存，最后执行读写操作。
​	计算机管理虚拟内存和物理内存的方式主要有两种：内存分段和内存分页。

### 2. 内存分段

​	进程的虚拟内存可以分为多个**逻辑段**，例如代码段、堆、栈。内存分段方式下，每个**虚拟内存地址由两部分组成，即段选择因子和段内偏移量**，段选择因子中含有段号，根据这个段号作为在**段表**上的索引，从而找到段的物理基地址，然后根据段基地址和段内偏移量映射到对应的物理内存上，具体过程如下： <img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/6-%E5%88%86%E6%AE%B5%E5%AF%BB%E5%9D%80.jpg" alt="内存分段-寻址的方式" style="zoom: 67%;" /> ![内存分段-虚拟地址与物理地址](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/7-%E5%88%86%E6%AE%B5%E5%AF%BB%E5%9D%80-%E4%BE%8B%E5%AD%90.jpg)  

内存分段简单，但存在问题：内存碎片和内存交换速率低。

#### 2.1 内存碎片

​	以分段形式管理的内存，容易产生多个不连续的内存块。这些不连续的内存块，只能给小于单个内存块大小的段使用，如果有某个段需要的内存比较大，就无法重新利用这些内存碎片，只能重新分配一块内存。

#### 2.2 内存交换速率

​	内存交换是用于解决内存碎片问题的一种措施。 ![内存碎片的问题](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/8-%E5%88%86%E6%AE%B5-%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87.jpg) 

​	上图中就产生了大小为128MB的内存碎片，两个128MB的内存碎片，无法满足一个200MB的内存需求。可以将蓝色部分先移动到硬盘上，然后再移回物理内存，但不会放置在原来的位置上，而是跟已分配的内存块紧密相连，这样两个128MB的内存碎片就整合到一起。但这样的措施每次都需要拷贝大量数据，会明显降低程序性能。

### 3. 内存分页

​	相较于分段，内存分页将物理内存与虚拟内存切成一段段相同大小的块，这样的块就叫做页，在32位的Linux系统中，一页的大小为4KB。虚拟地址通过页表映射到物理地址。 ![内存映射](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/9-%E5%88%86%E9%A1%B5.jpg)
​	内存分页的方式下，内存的释放是以页为大小进行释放的，不存在释放后留下无法给应用程序使用的内存碎片。在内存置换方面，当物理内存不够用时，操作系统会将最近没被使用的页写入到硬盘中，一旦有需要再写入到内存中，这样的内存置换每次仅以页为单位，开销比较小。

#### 3.1 虚拟内存通过页表映射到物理内存

​	首先是页表：页表是存储在物理内存中的数据结构，由操作系统维护，页表中存储着一个个页表条目(PTE)，PTE由一个有效位和n位地址组成，有效位用来标识当前页有没有被缓存在物理内存中。如果有效位被设置了，那么这个PTE的n位地址就标识物理内存中对应的页的起始地址。如果没有被设置，有两种情况：要么这个页被缓存在磁盘中，要么这个页还没有被使用(此时其它位标识一个空地址)。
​	当程序通过虚拟内存想要访问物理内存时：首先CPU中的MMU**将虚拟内存翻译为一个用于页表的索引**，通过这个索引找到对应的PTE，假如PTE有效位被设置，就通过PTE记录的起始地址，以及虚拟内存地址所记录的偏移值，映射到对应的物理内存的正确位置。 ![内存分页寻址](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/11-%E5%88%86%E9%A1%B5%E5%AF%BB%E5%9D%80.jpg) 

#### 3.2 缓存未命中的情况

​	当程序要访问的页不存在于**物理内存**中时，就发生缓存未命中的情况，这种情况又被称为缺页异常。缺页异常会使得内核调度缺页异常处理程序(先中断原程序，执行异常处理)。这个处理程序会从页表中选择一个牺牲页，将其复制到磁盘中，然后将原程序要使用的页从磁盘中复制到牺牲页的位置，然后更新页表，随后重启引发缺页异常的指令，即再次查找引发缺页异常的虚拟地址，只不过这一次，想要查找的页已经存在于物理内存中，因此一切正常进行。
​	例如：某个虚拟地址要映射到物理内存，它在页表中的索引为3，即索引到PTE3，此时查到页表中PTE3对应的页不存在于物理内存，而存在于磁盘，此时引发缺页异常。首先在页表中选择一个牺牲页，将其对应的缓存拷贝到磁盘中，并更新这个页对应的PTE的信息，然后将PTE3在磁盘中的内容，拷贝到物理内存中那个牺牲页的位置，并更新PTE3。到此便完成了缺页异常处理，然后再重启指令，重新映射。

#### 3.3 多级页表

​	单级页表很好地解决了内存分段会出现的问题，但它也存在不足之处。在32位系统中，一个进程的虚拟内存是4GB，如果是单级页表，每个页表条目(PTE)能映射4KB的内存空间，因此一个4GB虚拟内存的进程，就需要2^20个PTE，而每个PTE占4字节，因此**每个进程就需要4MB内存来储存页表**。
​	而多级页表可以极大降低页表所占内存。以二级页表为例：原来的单级页表中，每4KB内存对应一个页，相当于将4GB虚拟内存空间直接划分为若干个4KB的页，而如果是二级页表，则**在第一级可以不用划分那么细，可以划分为1024个区间，每个区间大小为4MB，由一级页表管理。而在第二级页表中，每个页表条目映射一个4KB的内存空间，这样只需要1024个二级页表条目，即可映射满一块4MB的片**。
​	可以看到，与单级页表相比，多级页表可以用非常少的页表条目管理4GB的虚拟内存空间。因为一个进程理论上有4GB，实际上用到的很少，用了多级页表之后，那些没有用到的内存，**就不用为它们创建二级页表，相当于直接省下了1024个页表条目。**
​	那么用了多级页表之后，页表的内存节约了多少呢？假设某个进程使用了20%的内存，那么它的页表条目开销总共为：一级页表的1024个，以及二级页表的1024 * 20% * 1024=209715，一个页表条目占4字节，那么就总共是（209715+1024）*4 = 210739 * 4  = 842956Bit = 842.956KB = 0.842MB。 相比原来的4MB，大大节省了内存空间。 

 ![二级分页](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/13-%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8.jpg) 

#### 3.4 TLB

​	多级页表减少了内存开销，但也带来了转换上的时间成本。由于局部性原理，内存访问通常会集中在某个内存区域。利用这一特性，把最经常被访问的几个页表项存储在CPU当中的一个缓存中，这个缓存就叫TLB，通常被称为页表缓存、快表等。
​	CPU在寻址时，会先去TLB中查找，找不到的时候再通过常规页表查找。

## malloc是如何分配内存的

### 1. 分配方式

​	malloc函数并不属于系统调用，而是C库函数。根据申请的内存大小，有两种分配方式：

1.  申请的内存小于128KB时，使用brk()函数将堆顶指针往上偏移。但偏移量并不一定跟malloc的参数一样大，为了防止频繁地申请内存，malloc会维护一个内存池，所以每次申请内存malloc会干脆分配一块较大的内存。
2.  申请的内存大于128KB时，使用系统调用mmap()在虚拟内存的文件映射区创建一块匿名映射，相当于从文件映射区''偷''了一块内存。mmap函数涉及系统调用，也就是说会发生用户态和内核态之间的切换。

### 2. 二者的比较

1. 调用free函数时，如果是brk()申请的内存并不会真的释放，而是保留在缓存池中待用。而mmap函数申请到的内存会被释放。

 	2. mmap函数申请到的内存，每第一次访问时都会触发缺页中断。而brk()不一定，因为这一次分配到的内存有可能之前已经被使用过，也就是说其对应的页已经存在于内存之中。
 	3. 通过brk函数申请的内存而维护的内存池存在内存碎片，例如从堆底从下往上看，有10、20、30k的内存，释放了10和20之后，如果下一次申请的内存小于30K，就可以直接拿下面那一段来用，如果大于就必须重新分配。而如果每次申请的内存都大于30K，那么释放掉的10+20那一段就一直不会被使用。某种意义上这甚至是一种内存泄漏。因此必须在申请内存小于128KB的时候才会使用brk函数。

### 3. 一些其它问题

1. free函数每次只传进一个指针，如何直到要释放的内存大小：实际上malloc申请的内存，都会加上一个头部，大小为0X10(十六位)，用于记录内存块的大小，而free只要将传进的指针往左偏移十六位即可得到内存的大小。

 	2. malloc分配的是什么内存：分配的是虚拟内存。如果分配的内存没有被使用，就不会映射到物理内存，只有被使用时才触发缺页中断，将对应的页从磁盘中加载到物理内存和页表中。

## Linux进程的虚拟内存分布

​	 ![虚拟内存空间划分](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/22-%E8%BF%9B%E7%A8%8B%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84.jpg) 

由图可得，0~3G的空间为用户空间，剩下的1G为内核空间。Linux中进程的虚拟内存各个段作用如下：

1.   .text：代码段，用于加载程序代码
2.  .data：存放已初始化的全局变量和静态变量
3.  .bss：存放未初始化的全局变量和静态变量
4.  堆：用于动态内存分配，从低地址向高地址生长
5.  文件映射区：用于mmap映射文件、加载动态库的区域，从低地址向高地址生长
6.  栈：用于存放非动态内存分配而来的变量、函数及其上下文。从高地址向低地址生长。