### 一、程序和进程

​	程序是编译后生成的、存储在硬盘中的二进制文件，，不占用系统资源，进程是程序运行起来后产生的，占用系统资源（cpu、缓存等），类似于剧本与演出之间的关系。

### 二、并发

​	![1644731291498](D:\DaSan\note\noteImage\1644731291498.png)

### 三、CPU的简易架构

![1644731358413](D:\DaSan\note\noteImage\1644731358413.png)

​	可以看到，存储介质是分了很多级的，越往下读取速度越慢同时存储容量也越大，CPU中有寄存器堆，其读取速度是最快的，但数量有限，容量也十分有限。当程序运行时，编译好的机器指令从硬盘中读到内存中，再读到缓存中，最终被CPU读取并解析。

### 四、MMU的作用

![1644731589811](D:\DaSan\note\noteImage\1644731589811.png)

​	MMU是CPU中用于处理内存的模块，主要作用是完成虚拟内存与物理内存之间的映射，以及设置内存的访问级别，在Linux中只有两个级别：用户级别和系统级别，分别对应虚拟内存中的0~3G部分和3G~4G部分。同一个程序可以产生多个进程，这些进程产生的虚拟内存以及它们映射到的物理内存是不同的，除了虚拟内存中的系统部分，系统部分是映射到物理内存的同一块地方的。同时，虚拟内存并不意味着真实地在物理内存上划分一块4G大小的内存给进程使用，而是进程用了多少物理内存就分配多少。

### 五、进程控制块PCB

​	进程控制块PCB是进程内核中的一个数据结构，用来维护进程进程相关的信息。在Linux中，其结构体包含以下成员：

![1644731925362](D:\DaSan\note\noteImage\1644731925362.png)

### 六、进程的五个状态







### 七、创建进程

### 7.1 创建单个进程

​	运行起来的程序就相当于一个进程，但进程可以创建它的子进程，利用fork函数，创建出来的子进程会从fork函数开始往后运行，也就是说可以在代码中用fork函数的返回值来判断当前是父进程在运行还是子进程在运行，如果是父进程，则返回的进程编号不为0（fork函数运行成功的情况下），如果是子进程则为0，运行失败时为-1。

### 7.2 循环创建多个进程

​	循环创建多个子进程，用for循环+fork函数实现，但要注意不能简单地将fork函数放在循环内就结束，因为如果这样，子进程会继续执行循环，也即会创建孙进程，这样产生的就不是N个进程，而是2的N次方-1个，解决方法是令子进程创建完成后就退出循环，同样地，利用fork函数的返回值来判断是不是子进程。
​	需要注意的是，父进程与创建出来的子进程在CPU眼中都是进程，地位平等，谁先抢占到CPU的资源谁就能够继续执行，所以子进程之间的执行顺序、子进程与父进程的执行顺序没有明确规定，为了使它们的行为有条理，可以利用sleep函数，越往后创建的进程sleep越久，这样就可以使得创建出来的进程按照一定先后顺序执行任务，最后才是父进程。

### 7.3 父子进程之间的共享

![1644772489208](D:\DaSan\note\noteImage\1644772489208.png)

需要注意的是：负自进程之间的全局变量是各自独立拥有的。

### 八、exec函数

​	![1644842902337](D:\DaSan\note\noteImage\1644842902337.png)

​	fork函数是用于创建一个子进程，该子进程几乎是父进程的副本，而有时我们希望子进程去执行另外的程序，exec函数族就提供了一个在进程中启动另一个程序执行的方法。它可以根据指定的文件名或目录名找到可执行文件，并用它来取代原调用进程的数据段、代码段和堆栈段，**在执行完之后，原调用进程的内容除了进程号外，其他全部被新程序的内容替换**。另外，这里的可执行文件既可以是二进制文件，也可以是Linux下任何可执行脚本文件。
​	在linux中使用exec族函数主要有两种情况： 当进程认为自己不能再为系统和用户做出任何贡献时，就可以调用任何exec 函数族让自己重生、 一个进程想执行另一个程序，那么它就可以调用fork函数新建一个进程，然后调用任何一个exec函数使子进程重生。 
​	需要重点掌握的是execl函数和execlp函数，path表示可执行程序的路径，file则表示文件名（将在PATH环境变量中查找），往后的都是执行程序时的必要参数，这里是一个可变参数包来容纳，注意最后一个参数必须是NULL。

### 九、回收子进程

### 9.1 僵尸进程与孤儿进程

1. 孤儿进程： 如果父进程先退出,子进程还没退出那么子进程将被托孤给init进程，这时子进程的父进程就是init进程(1号进程)，这种进程被称为孤儿进程。

 	2. 僵尸进程：如果一个进程已经终止了,但是其父进程还没有获取其状态,那么这个进程就称之为僵尸进程。僵尸进程还会消耗一定的系统资源,并且还保留一些概要信息供父进程查询子进程的状态可以提供父进程想要的信息，一旦父进程得到想要的信息,僵尸进程就会结束。

### 9.2 wait函数

![1644845940608](D:\DaSan\note\noteImage\1644845940608.png)

​	wait函数是父进程用来回收僵尸子进程的函数，它有三大特点：1. 阻塞等待子进程结束。  2. 回收子进程占用资源  3. 获取子进程结束状态（退出原因）。参数state为传出参数，用于记录结束状态。
​	要想获取进程结束状态，还必须借助一组宏函数：![1644846158425](D:\DaSan\note\noteImage\1644846158425.png)

### 9.3 waitpid函数

​	waitpid函数可以回收指定pid的进程，可以设置阻塞或非阻塞状态，比wait函数灵活。
​	参数：

​	1. pid：  大于0：回收指定pid进程   -1：回收任意子进程   0：回收和当前调用waitpid一个组的所有进程

  		2. options：0：阻塞状态   WNOHANG：非阻塞状态（这种状态返回0表示进程未结束）

### 十、进程间通信

### 10.1 管道

​	管道是一种不占用磁盘空间的伪文件，被两个文件描述符引用，一个写数据，一个读数据，，规定数据只能从写入端流入文件内，从读取端流出文件。管道实为内核使用环形队列机制，借助内核缓冲区实现，由于是队列，数据一旦被读取就不再存在于管道内，且只能单向通信，并且管道只能被有公共祖先的进程使用。
​	Linux中用于创建管道文件的函数是pipe函数：
![1644855481464](D:\DaSan\note\noteImage\1644855481464.png)

​	函数的参数为传出参数，因为它得被两个文件描述符描述，所以传出的是个fd数组，规定fd[0]为读取端，fd[1]为写入端，当一个进程使用pipe创建了管道时，它同时指向管道的输入输出端，因此必须根据代码逻辑来关闭某一端，可以用fork的返回值确定是父进程还是子进程，然后用close函数关闭读取端或者写入端

![1644855682139](D:\DaSan\note\noteImage\1644855682139.png)

​	需要注意读取与写入端对应的阻塞情况。

### 10.2 文件共享

​	文件共享是通过在进程虚拟地址中创建一块映射到物理磁盘的映射区来实现的，所使用的函数为mmap函数和munmap函数。![1644857316793](D:\DaSan\note\noteImage\1644857316793.png)

![1644857337343](D:\DaSan\note\noteImage\1644857337343.png)

munmap函数则是用于将开辟的映射区回收，只需传入映射区的地址和映射区大小即可。注意事项：![1644911832742](D:\DaSan\note\noteImage\1644911832742.png)

上述的方法每次都要建立一个文件，然后在进程结束对文件的使用时删除它，而匿名映射区不需要新键文件：![1644916490749](D:\DaSan\note\noteImage\1644916490749.png)

![1644916527466](D:\DaSan\note\noteImage\1644916527466.png)

### 10.3 信号

​	概念：信号是信息的载体，是一种古老的Linux/Unix系统环境下的通信方式，有三大特性：1. 简单 2. 不能携带大量信息 3. 满足某个条件才发送。A给B发送信号，B收到信号后，无论当时的程序执行到什么位置，都要停下来先处理信号，类似中断的处理机制。虽然信号是由程序决定发送的，但实际上的发送端是内核，内核负责信号的发送和处理
​	产生信号的五种方式：![1644931537866](D:\DaSan\note\noteImage\1644931537866.png)
​	信号送出后的情况：递达(可以认为是瞬时的)、阻塞(未决)。未决是一种处于产生和递达之间的状态，主要由于信号被屏蔽(阻塞)而产生。
​	信号的三种处理方式：
![1644931691414](D:\DaSan\note\noteImage\1644931691414.png)
​	上述的三种处理方式中，忽略也是一种处理，也即忽略后信号为已被处理信号，默认动作又可细分为以下五种：
![1644931754556](D:\DaSan\note\noteImage\1644931754556.png)

​	使用man 7 signal可以查看信号的一些信息，信号有四个要素：信号名称、信号编号、产生的原因和默认动作，这些都可以在man文档第七章中查到，主要用的上的信号为1~31，第9和第19个信号不可忽略也不可捕捉(即不可以用自己定义的行为来替代该信号的默认行为)。

​	关于信号的几个函数：

1.   kill :  int kill(pid_t pid, int sig)    作用是给指定编号的进程发送指定信号，成功返回0否则返回-1. 

2.   raise： int raise(int sig)    作用是给当前进程发送指定信号，成功返回0，否则返回非0值
3.   abort： void abort(void)   作用是给当前进程发送SIGABRT信号，将中止当前进程。
4.   alarm：unsigned int alarm(unsigend int second):   作用是利用定时器计时，指定几秒后结束当前进程，返回值为上一次调用alram后的剩余时间，例如alarm(5)，两秒后再alarm(5)，此时会重新从5开始计时，返回的就是3.
5.   setitimer：int setitimer(int witch, const struct itimerval* new_value, struct itimerval* old_value)：与alarm函数作用相似，但能够设置更高的时间精度、周期性计时以及计时方式

![1645001156433](D:\DaSan\note\noteImage\1645001156433.png)

![1645001311767](D:\DaSan\note\noteImage\1645001311767.png)

​	参数witch用来设置定时方式，参数new_value为传入参数，用来指定计时的秒数、下一次计时的秒数，old_value为传出参数，用来记录上一次计时所剩下的时间，与alarm函数的返回值相似。注意，其中的it_interval参数用于设置周期，value只是第一次计时的时间，例如它是五秒，然后设置周期是三秒，这样信号第一次是五秒后发出，之后的每一次都是三秒后发出。

6.  signal： signal函数用于为特定的信号指定一个用户自定义的默认行为，用传递函数指针的方法来设置![1645003027915](D:\DaSan\note\noteImage\1645003027915.png)

7.  信号集设置函数：信号集包括阻塞信号集和未决信号集，本质上是一个32位的数，其中每个位的0/1用来表示信号的阻塞与否，未决信号集受阻塞信号集影响，而阻塞信号集可以通过客户端编写的代码影响，方法就是使用系统提供的信号集设置函数：![1645004660597](D:\DaSan\note\noteImage\1645004660597.png)

![1645004703774](D:\DaSan\note\noteImage\1645004703774.png)

![1645004750985](D:\DaSan\note\noteImage\1645004750985.png)

8.  sigaction：int sigaction(int signum, const struct sigaction *act,struct sigaction *oldact)：同样是用于捕捉信号的函数，与singal函数类似，但功能更多，其传入结构体与传出结构体的构造如下：![1645016922099](D:\DaSan\note\noteImage\1645016922099.png)



一些关于信号的知识：

![1645016964577](D:\DaSan\note\noteImage\1645016964577.png)

![1645016978927](D:\DaSan\note\noteImage\1645016978927.png)

### 十一、守护进程

### 11.1 概念

![1645090569951](D:\DaSan\note\noteImage\1645090569951.png)

### 11.2 创建步骤

​	![1645090618346](D:\DaSan\note\noteImage\1645090618346.png)

