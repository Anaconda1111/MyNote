## 一、Socket编程

	### 1.1 socket相关概念

​	在Linux系统中，socket也属于文件的一种(不占用内存的伪文件)，与管道类似，但一个管道文件将有两个文件描述符，一个对应读端，一个对应写端，而socket文件没有，它用一个文件描述符完成读写，因此是一种全双工的通信方式。socket将ip地址与端口号绑定，使得一个套接字文件可以绑定网络中唯一的一台主机上的一个进程。

![1645762371118](../noteImage/1645762371118.png)![1645762572119](../noteImage/1645762572119.png)

### 1.2 网络字节序

​	实际上就是对于同一个数字，其高位对应地址高位，和高位对应地址低位这两种不同的存储方式使得数据表现不同，因此对于要发送到网络上的数据需要转换，从网络上接收到的数据也要进行转换

![1645762697759](../noteImage/1645762697759.png)![1645762862180](../noteImage/1645762862180.png)

​	用户表示IP地址的方式叫点分十进制，例如 192.168.150.129，这样的形式在代码中属于字符串，但上面的htonl函数的参数是个uint32，所以要先将其转换为数字，再转换为网络字节序。 为了方便，Linux系统提供了inet_pton函数，有三个参数**第一个是af，表示使用ipv4还是ipv6，用宏定义来选择；第二个是const char*类型，表示传入的ip地址字符串，第三个参数是void * 类型的，作为传出参数，表示转换好了的网络字节序**，使用这个函数可以一步到位，相应的，也有将网络字节序直接转换为字符串的inet_ntop

### 1.3 sockaddr结构体

![1645763520847](../noteImage/1645763520847.png)![1645763661150](../noteImage/1645763661150.png)

​	sockaddr是一个早期用于记录ipv4地址的数据结构，用于socket编程，后来演变为sockaddr_in，增加了端口号、地址类型等，但早期函数形参有一些是用的sockaddr，因此在使用的时候需要强制类型转换。

### 1.4 网络套接字函数

	1. socket函数：用于创建套接字，成功返回套接字文件fd，失败返回-1。其中第二个参数，如果是SOCK_STREAM就默认是TCP，SOCK_DGRAM就默认是UDP![1645764038333](../noteImage/1645764038333.png)
 	2. bind函数：用于将ip地址与套接字绑定，只有服务端需要调用这个函数，在客户端可以不必调用，但不代表没有绑定，不调用的话这个绑定的过程是操作系统完成的，它会自动分配一个ip地址，但服务端不可以用随意的ip，而应该用固定的，否则客户端找不到，因此必须用bind函数。![1645764244718](../noteImage/1645764244718.png)
 	3. listen函数：用于设置最多有多少台设备可以服务，默认值128，只有服务端需要设置
     ![1645764306390](../noteImage/1645764306390.png)
 	4. accept函数：服务端调用此函数阻塞等待客户端连接，注意它将返回一个新的socket文件用于和客户端连接![1645764378648](../noteImage/1645764378648.png)