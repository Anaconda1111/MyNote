## 一、基本概念和内核实现

### 1.1 基本概念

​	线程只能由进程产生，但CPU可以单独为进程分配资源，一个进程如果分为多个线程，就能提高程序运行效率

![1645365483320](D:\DaSan\note\noteImage\1645365483320.png)

### 1.2 内核实现

​	![1645365907569](D:\DaSan\note\noteImage\1645365907569.png)

### 1.3  线程之间共享与不共享、进程优缺点

​	1. 共享：![1645367954520](D:\DaSan\note\noteImage\1645367954520.png)

2.  不共享：![1645367973068](D:\DaSan\note\noteImage\1645367973068.png)

3.  优缺点：![1645367985056](D:\DaSan\note\noteImage\1645367985056.png)

## 二、进程控制原语

### 	2.1 pthread_self函数

​	用于查看线程id，注意：**线程id与线程号不一样，前者用于在进程内分辨不同线程，后者用于CPU为线程分配资源**。
![1645370575006](D:\DaSan\note\noteImage\1645370575006.png)
​	其返回值类型为pthread_t，也即unsigned long，注意，用线程库函数后在编译时需要加上参数 -pthread。

### 2.2 pthread_create

![1645370699591](D:\DaSan\note\noteImage\1645370699591.png)	该函数用于创建线程，参数作用为： 1. thread：传出参数，用于记录创建出的线程的id，当创建失败时该变量未定义。  2.  attr：线程的属性设置，传入NULL时使用默认属性。 3. start_routine：进程所需要执行的函数，其参数和返回值都为void *，进程一旦创建将运行这个函数。  4.  arg：参数三指向的函数所需要的参数。    返回值：创建成功时返回0，否则返回其它错误码，用返回值来做错误判断时需要特别注意。

### 2.3 pthread_exit

![1645432831457](D:\DaSan\note\noteImage\1645432831457.png)
	该函数用于线程退出，线程的退出与进程不同，如果使用exit函数，退出的将是整个进程，此时所有的线程都会退出，如果使用的是return，在线程回调函数以及回调函数所调用的函数中使用是没问题的，但如果在main函数中使用，也会使得整个进程退出，进而导致所有线程退出，因为return的含义是返回调用端，因此，**退出线程时尽量在线程回调函数中使用pthread_exit函数，main函数中使用return时注意是否需要加sleep函数等待其它线程执行完毕**

### 2.4 pthread_join

![1645434624682](D:\DaSan\note\noteImage\1645434624682.png)
	该函数用于回收子线程，并通过变量retval获取子线程退出值(即函数pthread_exit的参数)，另一个参数是要要回收的子线程的线程id。类似于回收进程的wait函数，它将阻塞地等待线程执行完毕并进行回收。

### 2.5 pthread_detach

​	![1645435412602](D:\DaSan\note\noteImage\1645435412602.png)

​	该函数用于将线程分离。与进程相似，如果线程退出后没有进行回收，将变成僵尸线程，但如果将线程从原进程中分离，那么当它执行完毕时会自动回收资源，同时原进程中其它线程也无法对该分离线程进行回收。

### 2.6 pthread_cancel

![1645435962276](D:\DaSan\note\noteImage\1645435962276.png)
![1645436080302](D:\DaSan\note\noteImage\1645436080302.png)

​	该函数用于杀死线程，被杀的线程回收时，join函数的传出参数固定是-1。

## 三、线程同步概念及各种锁

	### 3.1 线程同步概念

​	同一进程下的线程共享各种资源，包括各个全局变量、文件描述符（包括标准输入输出等），且线程之间对这些资源的使用是竞争的，也就是说，如果不对线程使用共享资源进行同步，就有可能出现多个进程在各自的CPU时间内对同一份资源进行使用与修改，最终资源可能被线程A改了一部分，又被线程B改了一部分，最终结果混乱。而解决这种现象的方法就是给资源加上锁，一个线程使用资源时，首先必须进行lock，如果它在使用过程中失去CPU，而其它线程试图访问这个资源时，就会由于不持有锁而访问失败。

### 3.2 互斥量及其操作函数

​	互斥量是Linux系统提供的一把锁，线程尝试对资源进行操作前，要先进行加锁操作，成功了才能继续执行，否则就代表有其它线程正在使用该资源，于是阻塞等待锁释放。当然这种规则要依托于程序员实现，如果编写了一个线程，不按照这种规则先进行加锁操作，而是之间访问资源，也是可以的，只是结果可能会混乱而已，这里的锁并不属于语言内部特性，而是代码编写者自己约定的东西，而这个互斥量，本质上也只是个结构体而已。

1.  pthread_mutex_init：用于创建互斥量的函数，第一个参数为传出参数，关键字restrict可以防止其它指针修改mutex，至于后一个参数，是设置互斥量的属性的，一般设置为NULL
    	![1645537856557](D:\DaSan\note\noteImage\1645537856557.png)

2.  pthread_mutex_destory：用于销毁互斥量，将创建时获得的传出参数传进去即可。
3.   pthread_mutex_ lock、 pthread_mutex_ unlock：这两个函数用于获得锁与释放锁，注意lock是阻塞的，一旦没有成功获得锁，将阻塞等待其它线程释放锁。应当尽量**减小锁操作的粒度**，也即，当在线程调用函数中使用完资源后，应当立即执行释放锁的操作。
4.   pthread_mutex_ trylock：与lock类似，这个函数用于获得锁，但如果未能成功，它不会阻塞，而是放弃线程拥有的所有锁。

### 3.3 死锁

​	死锁指的是由于代码逻辑，导致某个线程永远阻塞在等待资源释放。第一种情况是unlock函数写成lock函数，第二种情况是A拥有锁1，想再尝试获得锁2，同时B拥有锁2，想再尝试获得锁1，这种情况下如果线程AB使用lock函数，将因为想要获取的资源在对方手上而永远阻塞，解决方法就是使用trylock。

### 3.4 读写锁及其操作函数

​	读写锁是一种不同于互斥量的锁，它可以有两种锁住的状态，即读锁和写锁，遵循两个规则：1. 写独占，读共享：假如线程A对资源进行读锁，而后有BCD同样请求对资源进行读锁，是可以通过的，因为读锁是可以共享的，但，只要其中有一个是写锁就不行。而如果A是写锁，那么其它线程无论是想要进行读锁还是进行写锁，都不允许共享，要等待A释放。  2.  写锁优先级高：多个线程等待资源释放时，尝试进行写锁的线程将更有限获得资源。
​	读写锁有专属于自己的操作函数，与互斥量的操作函数相似，包括init、destroy、lock、unlock、trylock，不同的是，lock与trylock有读写之分![1645543510842](D:\DaSan\note\noteImage\1645543510842.png)