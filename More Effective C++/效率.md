

### 条款16 谨记20-80法则

​	80-20法则：一个程序80%的资源用于20%的代码身上，当发现程序的效率需要提升时，可行之道是完全根据观察或实验来识别出那20%的代码并进行优化，辨别之道是借助某个程序分析器。

### 条款17 考虑使用lazy evaluation (缓式评估)

​	缓式评估有点像拖延战术，大概就是某部分操作或运算先不进行，等到非要用到其结果时再去实施。缓式评估大概有四种用途：

1.  Reference Counting(引用计数)：当一个对象赋给另一个对象时，普遍的做法是调用其copy constructor，但如果涉及动态内存分配，调用new和逐一复制的成本很高。而lazy做法就是先让这两个对象分享同一份数值，只有当涉及修改对象中的数据时才进行真正的复制工作。在你真正需要之前，不必着急为某物做一个副本，取而代之的是拖延战术，只要能够，就使用其它副本。

 	2. 区分读写：
 	3. Lazy Fetching(缓式取出)：如果一个对象非常大型，且由多个字段组成，那么每次使用一个对象都要从数据库中取出对象的所有数据，但取出后不一定所有字段都用上。所以可以在类的声明时声明若干个指针指向若干个字段，先初始化为null，类的每一个成员函数在使用其字段前先检查是否为空，如果是再从数据库中读入然后操作数据。
 	4. Lazy Expression Evaluation(表达式缓式评估)：当要计算两个大型矩阵的运算时，可以先不立即进行，而是用一些数据结构来保存，例如m3=m1+m2，那么可能只是先由两个指针和一个枚举变量构成，前者指向m1和m2，后者用来表示运算类型是加法，当下一句语句是m3=m1*m2时，就改为乘法运算，这样就避免大量不必要的运算。   而其更常见的一种情况是，取大型运算中的部分运算结果，例如cout<<m3[4]，就计算m3第四行的结果就行。

当你的计算绝对必要时，lazy evaluation甚至会使程序更加缓慢并增加内存用量。

### 条款18 分期摊还预期的计算成本

​	超急评估(over-eager evaluation)：在被要求之前就先把事情做下去。假设存在某个类用于收集数据，它的成员函数中有求最大、最小和平均值，实现方法有三种。一种是普通的eager evaluation，调用时再计算，第二种是lazy evaluation，在函数的返回值真的要派上用场时再进行计算，第三种则是over-eager evaluation，也就是随时记录数据的最大最小和平均值，一旦要调用就直接返回。如果程序**多次**调用这些函数，那么每次调用付出的成本就被摊还，会比前两种都低。
​	超急评估背后的观念是如果预期程序会经常使用某个计算，你可以降低每次计算的平均成本。
​	一个做法是将“计算好的而有可能再被需要”的数值储存，例如某个程序会大量使用职员的号码牌，而其号码牌存储在数据库中，那么可以建立一个静态的容器(例如map)来保存每次读取到的号码牌，当要查找的号码牌不再map中时再去数据库寻找。
​	另一种做法是Prefetching(预先取出)，这一点在STL容器的底层实现中非常常见，例如某个容器是动态内存分配，当你的代码想要往其中放入20个数据(也就是说你创建一个含20个位置的容器)，STL的实现往往会申请一个两倍大小的容器返还给你，这样当你下次有一个新的值要放入其中时就不必重新申请内存然后进行复制了。这背后的依据是**如果某处的数据被需要，通常其临近的数据也会被需要**。

### 条款19 了解临时对象的来源

​	C++真正的所谓临时对象是不可见的——不会在源码中出现，通常产生于两种情况：一是为了函数能够成功调用而实施的隐式类型转换，第二种是函数返回对象的时候。
​	情况一：

```c++
size_t countChar(const string& str,char ch);
char buffer[MAT_STRING_sIZE];
char c;
countChar(buffer,c);
//这里传入是一个char数组，与函数的形参类型不吻合，当不吻合情况发生时，编译器为了消除这种状态会产生一个
//临时的string对象，以buffer为自变量初始化它，于是函数中的形参便与该临时对象绑定
//当函数执行完毕时临时对象销毁
//只有当对象以by value方式传递或对象被传递给一个reference to const参数时这些转换才会发生
```

### 条款20 协助完成“返回值优化（RVO）”

​	如果函数一定得以by-value方式返回对象，你绝对无法优化这一点，此时应该考虑的是怎么降低返回对象的成本而不是考虑改变返回类型。

```c++
const Rational operator*(const Rational& lhs,const Rational& rhs){
    return Rational(lhs.numerator()*rhs.numberator(),lhs.denominator()*rhs.denominator());
}
Rational a=10;
Rational b(1,2);
Rational c=a*b;
//上述代码中，operator*内的返回值是直接调用该类的构造函数，此时编译器可以将其构造于对象C的内存中
//这样该函数的临时对象成本为0
//而原本是必须返回一个临时对象，要付出其构造和析构的代价
```

### 条款21 利用重载技术避免隐式类型转换

```c++
class UPInt{
    public:
    	UPInt();
    	UPInt(int value);
    	...;
};
const UPInt operator+(const UPInt& lhs,const UPInt& rhs);

UPInt upi1,upi2;
...;
UPInt upi3=upi1+10;
upi3=10+upi2;//这两条语句都能通过编译，因为10被转换为UPInt的一个临时对象
//虽然看起来方便，但产生的临时对象会带来一些成本，可以通过重载的方法消除这些成本：
const UPInt operator+(const UPInt& lhs,int rhs);
const UPInt operator+(int lhs,const UPInt& rhs);//这个函数一般得是友元
```

### 条款22 考虑以操作复合形式(op=)取代其独身形式(op)

​	操作符的独身形式，例如operator+往往涉及临时对象的构造和析构，容易造成效率上的低下，而复合形式，例如operator+=返回的是引用，只需将右边的对象加到左边对象本身然后返回左边对象即可。因此可以考虑用复合形式代替独身形式，并且后者通过前者实现：

```c++
class Rational{
    public:
    	Rational& operator+=(const Rational& rhs);
    	Rational& operator-=(const Rational& rhs);
}

const Rational operator+(const Rational&lhs,cosnt Rational& rhs){
    return Rational(lhs)+=rhs;//高效实现独身操作符，且这样的写法可以适用返回值优化
}
```

### 条款24   了解虚函数、多重继承、虚基类和RTTI的成本

 1.    ​	虚函数：虚函数的是实现多态的重要工具，为了实现虚函数，编译器使用虚表和虚表指针。虚表是一个由函数指针组成的数组，凡是声明或继承虚函数的类都会有自己的虚表，虚表中存放的是虚函数的地址，类中的非虚函数则不存在虚表当中。虚表指针是声明了虚函数的累的一个隐藏成员，用来指向该类的虚表，只有编译器才知道它的位置。
       ​		再来看看虚函数被调用时编译器是怎么做的：

       ```c++
       //注：C1是基类，f1()是C1和它的派生类C2都有各自定义的虚函数
       void makeACall(C1 *pC1){
           pC1->f1();
       }
       //要将上述函数产生可执行代码，必须完成以下动作：
       //1.根据对象的虚表指针找出虚表，这对编译器来说不难
       //2.找出被调用函数在虚表内的对应指针
       //3.调用步骤2所得指针所指向的函数
       //假设函数f1在虚表里的位置是i，虚表指针为vptr，则产生出来的代码类似：
       (*pC1->vptr[i])(pC1);
       //调用pC1->vptr所指的虚表中的第i个条目所指函数，PC1被传给该函数作为“this”指针之用
       //也就是说，调用一个虚函数的成本基本上和“通过一个函数指针来调用函数”相同
       ```

       ​	因此，虚函数的运行时期成本不在于调用它，而在于它和inline的混用，因为virtual意味着要到运行时期才知道哪个函数被调用，这也注定虚函数无法使用inline
       ​	至此我们可以总结虚函数的三个成本：1. 每个类一个虚表，但其总空间通常不大。  2. 拥有虚函数的对象内都必须有一个额外指针（也就是虚表指针）。  3. 虚函数无法使用inline。

	2. ​     多重继承和虚拟基类：当存在多重继承，且派生类在其基类有多条继承路劲时，虚基类显得很有必要，否则基类的成员会在派生类中复制多份，而虚基类带来的成本就是可能会多几个隐藏指针(由继承了虚基类的类带来，它们指向基类)。 更重要的是，多重继承也会带来多个虚表指针，以菱形继承为例：

    ```c++
    class A{...};
    class B:virtual public A{...};
    class C:virtual public A{...};
    class D:public B,public C{...};
    //此时类D中就含有三个vptr，理论上来说应该有四个，但是D会和B(第一个父类)共享一个vptr，那么这三个vptr
    //各自指向了三个虚表，D定义的，不覆盖任何父类虚函数的新的虚函数将放在其与B共享的虚表之后
    ```

    