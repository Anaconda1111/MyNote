### 条款6 区别自增/自减操作符的前后置形式

​	C++对++和--操作符的前置式和后置式具有重载能力。此时会出现一个问题：二者的前置式和后置式都没有参数，为了解决这个问题，只好让后置式的重载函数拥有一个默认为0的int型变量。

```c++
class UPInt{
    public:
    	UPInt& operator++();		//前置式
    	const UPInt operator++(int);//后置式
}

UPInt& UPInt::operator++(){ //前置式：累加后取出
    *this+=1;
    return *this;
}

const UPInt UPInt::operator++(int){  //后置式：取出后累加
    UPInt old=*this;
    ++(*this);
    return old;
}
```

​	代码中更重要的是，前置式和后置式返回不同类型，前置式返回一个引用而后置式返回一个const对象。返回const对象是为了防止形如i++++的调用，有两个理由必须防止这种调用，第一是这种行为C++的内建类型也不合法，第二是即使合法，它也只是把原对象加+1而已，因为第二个后置++改变的是第一次的返回值而不是原对象，因此不符合预期。

​	可以看到上述实现的代码中，后置式的自增/自减操作符的实现应该以前置式为基础，这样就只需要维护前置式的代码。并且，后置式的代码效率明显比前置式低很多，它需要返回一个临时对象，而前置式只是修改原对象。因此没有特殊要求时一律使用前置式。

### 条款7 千万不要重载&&和||和，运算符

​		C++中普通的&&和||运算符存在一个“骤死式”语义，例如：if(p!=0&&strlen(p)>10)，当p为0时后面的语句将不再执行，这便是“骤死式”，而它也确保了程序不会出错，因为strlen传入空指针时的行为是未定义的。但如果类重载了&&或||时，使用&&或||操作符就相当于是调用函数，而函数调用动作被执行时，所有参数值都必须评估完成，此时就不存在“骤死式”语义了。

​	而关于逗号操作符：如果表达式内含逗号，逗号左侧会先被评估，然后是右侧，最后表达式的值为逗号右侧的值，如果把逗号操作符重载时无法做到其行为与上述一致。

​		

