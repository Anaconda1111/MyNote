## 一、函数指针

### 1.1 概念

​	函数也有自己的地址，函数的地址是存储其机器语言代码的内存的开始地址。将函数的地址作为另一个函数的形参，这样能够允许第二个函数在不同的时间运用不同的函数进行操作。

### 1.2 用法

 1.    获取函数地址：获取函数地址十分简单，只要使用函数名即可。例如think()是一个函数，则think就是该函数的地址。

 2.    声明函数指针：

       ```c
       double pam(int); //这是一个函数的声明
       double (* function_p)(int) //这是一个函数指针的声明 表示指向一个返回double，含一个int参数的函数
       function_p=pam;  //现在function_p就指向函数pam的地址，*function_p()等同于pam()    
       ```

       注意：声明函数指针时星号与变量名需要用括号括起，否则像 double *pt()就表示函数的返回值是一个指向double类型的指针，而不是声明指针函数了。

3. 使用指针调用函数：

```c
double pam(int);
double (*pf) (int);
pf=pam;
double x=pam(4);
//以下两种用函数指针调用函数的方法都成立，虽然看起来相互矛盾。属于历史遗留问题
double y=(*pf)(5);
double y=pf(5);
```

## 二、内联函数

### 2.1 概念

​	常规函数与内联函数的区别不在于编写方式，而在于C++编译器如何将它们组合到程序中。程序中的每一条指令都有特定的内存地址，常规函数调用时使程序跳到另一个地址，并在函数结束时返回。对于内联函数，程序无需跳到另一个位置执行代码再跳回来，因为编译器将使用相应的函数代码替换函数调用，因此内联函数的运行速度比常规函数稍快，但代价是占用更多内存。只有使用频率较高且函数体较短的函数才适合定义为内联函数。

### 2.2 使用

​	声明一个内联函数时，必须在函数的声明或定义前加上**inline**关键字。且编译器不一定会满足程序员的要求，它可能认为函数过大或该函数调用了自己(内联函数不能使用递归)从而拒绝将其作为内联函数。

### 2.3 内联与宏

​	相较于内联，宏定义不能按值传递。

```c++
#define SQUARE(X)  X*X
a=SQUARE(5.0);
b=SQUARE(4.5+7.5);
c=SQUARE(c++);
//上述abc中，只有a能得到正确结果，因为按照定义，b将等于4.5+7.5*4.5+7.5，除非将SQUARE的定义改为((X)*(X)),而且就算改成这样，当计算c的时候，c这个变量也会自增两次。
```

因此可以看出，如果用宏实现了类似函数的功能，最好用内联函数替换。

## 三、引用变量

### 3.1 概念

​	引用变量是一张C++新增的复合类型。引用是已定义变量的别名(另一个名称)，例如用twain作为clement变量的引用，则可以交替使用twain和clement来表示该变量。引用变量的主要用途是作函数的形参。

### 3.2 用法

​	1.创建引用变量：

```c++
int rats;
int & rodents=rats; //这里的rodents就是变量rats的引用，声明引用变量的格式为：变量类型 & 名称；引用变量
				  //一旦声明，就必须初始化，这点与指针变量不同。
```

该例子中引用变量rodents就是变量rats的别名，它们指向相同的值和内存单元，当把一个值赋给rodents时，rats也相应地变成这个值。且引用变量一旦与某个变量关联起来，就将一直效忠于它。

2.  用作函数参数：

    ```c++
    void SwapR(int & a,int & b);
    void SwapP(int *p1,int *p2);
    void SwapV(int a,int b);
    int mian(){
        int a=3,b=4;
        SwapR(a,b);   //有效
        SwapP(&a,&b); //有效
        SwapV(a,b);   //无效
    }
    ```

    该例子表明，将函数的形参定义为引用变量时，可以改变原始数据，这与传指针的方法类似，但调用函数时不必使用取地址符。且传递引用变量比起常规的变量将更加严格，例如，x+3这样的实参不可以传递给引用，因为表达式不是变量。

3.  const与临时变量：当函数的引用形参前加了const修饰符，则当：1.实参类型正确但不是左值。2. 实参的类型不正确但可以转换为正确的类型。 这两种情况发生时，将生成临时变量。

    ```c++
    double refucube(const doube &ra){
        return ra*ra*ra;
    }
    long edge=5L;
    double side=3.0;
    refucube(edge);   //类型不正确但可以转换
    refucube(7.0);    //非左值
    refucube(side+3.0);  //非左值
    
    //在上述情况下，由于函数形参是加了const修饰符的引用，因此编译器将生成一个临时匿名变量，并让ra指向它
    //这些临时变量只在函数调用期间存在，但同时，若陷入这种产生匿名变量的情况，则函数不会修改原始数据
    ```

4.  将引用用于结构体变量
    使用结构体引用的方法与使用基本变量引用相同。引入引用本身是为了用于结构体和类，因为结构体和类本身可能将包含非常多元素，传统的传递参数方式将使程序不得不复制一个副本进行操作，使用引用可以节省这部分开销。且函数的返回值也是同理，若是返回一个确切的值或是一个结构体，则程序会先将整个结构体复制到一个临时位置再拷贝给要赋值的变量，若返回的是引用则可以直接复制，更加高效。需要注意的是，应避免返回函数终止时不再存在的内存单元，如函数内声明的变量。

### 3.3 关于引用的需要注意的事项

 1.    引用指向“null”的情况：引用指向null的情况是一种未定义的行为，可能会引发未知的错误，因此绝对不要让引用指向空指针的解引用值！

       ```c++
       char *pc=nullptr;
       char &rc=*pc  //令引用指向null指针的解引用值，未定义行为！
       ```

 2.    如何在引用与指针之间做出选择：

​	当你需要指向某个东西且绝对不会变成指向其它东西时，或你实现一个操作符而其语法需求无法由指针达成时就应该使用引用，否则其它情况都应该使用指针。

## 四、默认参数

### 4.1 概念：

​	默认参数指的是函数调用中省略了实参时自动调用的一个值，如void WOW(int n=1)，当调用函数且没有实参赋给形参n时，形参n默认为1，若给出值则n等于调用时给出的实参。例如WOW()时n=1，WOW(5)时n=5。添加默认参数必须从右向左添加。

### 4.2 用法：

```c++
int harpo(int n,int m=4,int j=5);//m与j为默认参数，且从右向左排列
beeps=harpo(2);			//调用harps(2，4，5)
beeps=harpo(1,8);		//调用harpo(1，8，5)
beeps=harps(8,7,6);		//调用harpo(8，7，6)
```

注意：只有在函数声明时才需要指定默认值，函数定义与不使用默认参数时完全一致

## 五、函数重载

### 5.1 概念：

​	函数重载(函数多态)可以让程序中存在多个同名的函数，只要它们的参数列表(特征标)不同（补充：返回类型可以不同，只要特征标不同）。

### 5.2 用法：

```c++
void print(const char *str,int width);
void print(double d,int width);
void print(int i,int width);
void print(const char *);
//以上四个print()函数的声明都是成立的，它们拥有不同的特征标，构成函数重载。在调用函数时，编译器会自动匹配对应
//的原型
```

当编译器无法确定究竟应该使用哪个原型时便会报错。因此引用变量和类型本身将被视为同一个特征标，例如：
double cube(double x) 和double cube(double & x)，以及一些情况下，当调用不与任何原型匹配时，编译器会尝试进行强制类型转换，但如果有**多个原型都可以通过强制类型转换而与调用匹配**时，编译器会报错。

## 六、函数模板

### 6.1 概念：

​	函数模板是通用的函数描述，也就是说，它们使用泛型来定义函数，其中的泛型可用具体的类型(如 int，double)替换。

### 6.2 用法：

1.  基本用法：

```c++
template <typename AnyType>
void Swap(AnyType &a,AnyType &b){
    AnyType temp;
    temp=a;
    a=b;
    b=temp;
}
//第一行指出建立一个模板 命名为AnyType，关键字typename可以用class代替。模板不创建任何函数，而只是告诉编译器 //如何定义函数。例如，需要交换int的函数时，编译器将按照模板创建形参为int的函数。
```

注意：函数模板并不能缩短可执行程序，当调用不同类型时，程序仍然由几个对应不同类型的函数组成。使用模板仅仅是为了编程方便。

2.  模板重载：可以像重载常规函数定义那样重载模板定义

    ```c++
    template <typename T>
    void Swap(T &a,T &b);
    
    template <typename T>
    void Swap(T *a,T *b,int n);
    
    //上述两个swap函数一个用来交换常规变量，一个用来交换数组的前n个值。第一个模板的特征标为(T &,T &),第二个  //模板的特征标为(T *,T *，int),二者拥有不同的特征标，因此可以重载，在调用时编译器根据传入的形参自动匹配 //对应模板
    ```

3.  具体化：函数模板无法处理某些类型，例如 T a=b*c，当T为数组，结构体或指针时将出错。要解决这种问题的一种方法是为特定类型提供具体化的模板定义。C++98选择了以下方法进行具体化：1. 对于函数，可以有非模板函数，模板函数和**显示具体化**模板函数及它们的重载版本。 2. 显示具体化的原型和定义应以template<>打头，并通过名称来指出类型。 **3. 具体化优先于常规模板，非模板函数优先于具体化和常规模板。** 

     实例化：对于模板，程序在调用函数时导致编译器生成模板的一个实例，实例对应调用时使用的类型（int、double或char），这个过程称为实例化。普通的实例化称为**隐式实例化**，C++允许进行显示实例化，这意味着可以直接命令编译器创建特定的实例，如Swap<int>()。**隐式实例化，显式实例化和显式具体化统称为具体化**。

    ```c++
    template <typename T>
    void Swap(T &,T &);  //隐式实例化
    template<> void Swap<job>(job &,job &);//显式具体化 语法特征是template后加<>
    template<> void Swap(job &,job &);//也是显式具体化，与上一行的声明等价
    int main(){
        template void Swap<char>(char &,char &);//显示实例化 与具体化的区别就在于template后没有尖括号
        short a,b;
        Swap(a,b);	//这里将模板隐式实例化
        
        job n,m;
        Swap(n,m);	//这里将调用显式具体化
        
        char g,h;
        Swap(g,h);  //这里将调用显式实例化
    }
    ```

    

##  七、一些琐碎的内容

1.  数组指针与指针数组

    ```C++
    int (*Array) [n];  // 数组指针，表明Array是一个指向包含n个int型变量的数组的指针
    int  *Array  [n];  // 指针数组，数组中的每个成员都是一个指向int型变量的指针
    // 二者的区别在于括号。第一行中括号的优先级最高，使Array与*结合，而表明Array是一个指针，而int与[n]       //表明Array指向的是一个int型数组
    //第二行，当没有括号的时候，[n]的优先级比*高，所以Array首先与[]结合表明这是一个数组，而后的int *表明     //数组成员是指针
    ```

2.  const修饰符：对于函数的参数而言，const修饰的形参可以接受const和非const实参，但const修饰的实参不可以传递给非const修饰的形参。

3.  

